DONE 1 - gérer le nombre d'argument de ./minishell avec les erreurs -->  Tristan

DONE 1a- vérifier si les quotes sont toutes fermés !!!!!!!!!!!!!!!!!!!!!!!! faut renomer la func first_quote pour etre plus general d ailleurs on peut
surement utiliser ft_strchr a la place  ---- 

DONE 2 - séparer lorsqu'il y a un pipe == changer de structure
    si erreur de pipe c'est prio 0
    si non erreur 2a
DONE 2a -  création de structure

DONE 3 - interpréter les variables $ sauf si 'single quote'

DONE 3a - Recuperer in files et out files en laissant quote + remove des redir dans le cmd --> TRISTAN

PEUT ETRE Verifier variable dans les redirs

DONE 3b - separer args en laissant quotes  --> a voir

DONE 3 c -suprimer les quotes  --> NIL

DONE  Ajouter interpretation $?  ->   penser à $12dsfsgd ça donne 2dsfsgd et 						rajouter les '_'  comme char valide.

			


DONE creer une fonction qui verifie si Bulting sinon go execve 

DONE 4 - HEREDOC

DONE 5 - PIPEX

DONE 5 - REDIRECTION parsing à l'ouverture

DONNE 6 - BUILTNGS

DONE 7 - gérer les signaux

signal() pour set nos functions qui gere les signaux

sigaction() je crois aussi pour set les funct permet de selectionner
	quels signaux prendre en compte, utilise une struct pour avoir plus
	d info

sigemptyset() inizialise la struct sigset_t envoyer, utiliser comme mask
de selections des signaux pour la struct de sigaction()

sigaddset() ajoute des signaux au mask sigset_t 

kill() pour envoyer un signal a un enfant

en mode interactif
	ctrl - c SIGINT
	ctrl - \ SIGQUIT
DONE (pour le parent a voir pour les enfant normalement ctrd envoie un EOF donc ca devrait se gerer tous seul dans les enfant)
	ctrl - d call ft_exit with no arg

quand on un enfant est actif faut lui envoyer le signal et pas le gerer dans le parent

DONE env ->
	precision, env n affiche pas les variable NULL c est a dire
	les variables definie comme ceci > "export VAR"
	contrairement a "export VAR=" qui n est pas NULL mais vide
	quand on appelle un exe on lui transmet les variables env mais pas
	les NULL du coup j ai modifier convert_env_strs pour ne transformer que
	les VAR non NULL le seul probleme c est que on peut allouer trop de
	memoire vu que ca se base sur envlink_size qui compte sans distinction
	des content NULL
	J ai verifier aussi d export une VAR NULL et ensuite de lancer un autre bash, 
	il ne recupere pas les variables NULL donc le convert_env_strs marchera niquel
	pour les execve en occultant les NULL

DONE echo NIL

cd  NIL
	cd  : va chercher $HOME  mais si $HPME n'est pas defini --> bash: cd: HOME not set
	cd arg1 arg2 (et/ou plus) : too many arguments
	Message d'erreur pour cd arg1 : bash: cd: arg1: Permission denied
					 bash: cd: arg1: Not a directory
					 bash: cd: arg1: Not such a file or directory
	si cd .. revenir au folder-1
					 
DONE pwd NIL getcwd, 
DONE export TRISTAN 
	comme exit, si dans un pipe se fait dans un enfant et la variable
	export ou modifier ne l est que dans l enfant

	Les noms peuvent contenir chiffres (mais pas commencer par) et lettres et _ , d ailleurs il faudrat peut etre ajouter 
	des "|| char == '_'" dans les conditions de lecture du nom de variable
	pendant l interpretation

	si le nom est pas bon conduit a une erreur IDENTIFIER avec la chaine de char concerne
	Ca me fait me demander, on doit pas gerer les charactere speciaux 
	pour minishell, on devrait les chercher tous en faire un define 
	et si on tombe dessus dans l'input (sauf dans les quote et double)
	on fait un unexpected token,

	et pour finir comme dit plus haut "export VAR" la variable est nul
									  "export VAR=" variable vide

DONE unset TRISTAN

DONE exit
	
	Plus d infor :	effectivement return le modulo 255 sur 8 bits donc
	long, et ensuite verifie si ce modulo est entre 0 - 127 et apres
	ce sont les signaux 128 + N (si en dehors range renvoir 0)
								ou N[0 - nombre de signaux gerer]. 

	Bash gere 7 signaux a partir de 0 donc 128 ... 134, je suppose que
	nous on devrait le mettre a 130, 
	pour l instant je vois que 3 signaux mais a voir.

	si l arg contient autre chose que 1 - ou + devant et des chiffres derriere
	-> exit avec code 2 et on ecrit erreur numeric argument required

	bizarement apres plein de test l argument est recuperer en tant que int normal puis cast en tant que unsigned int MAIS l'argument est accepte dans les limites d un long 

	Jpensais faire ca la mais tu verras l heure du message ahah, et y a plus de boulot que j avais prevu apres tous ces test jferais surement exit "demain"
	
	
 2.1 exve
 	cmb de il y a de pipe. savoir si c'est pair(even) ou impair(odd)
	si n'existe pas error_handler;
	faire un tableau de PID.
	->enfant
	set les g_return
	si bultin ou cmd n'existe pas PID[i] = -1; 
	
 signal_handler pour child --> kill()

 2.2 redirection

 2.3 here_doc

 2.4 pipe
 
 
 Si unset PATH faut ft_free_strs le char **path
  Si export PATH faut ft_free_strs et recalculer le char **path
 
 done dans check_redir O_truncsi et append
 
 ---------------------------------------------------------------
 
 faire here_doc 
 
 verifier les executable ---> ./blabla : handle_bad_cmd
 
 here_doc signal
 
 verifier les signaux quand ./minishell ./minishell
 
 initialiser heredoc avant preparation fork et do build_in
 si builtin mais pas echo close les heredocs
 
 init_redir 2eme compteur pour heredoc le fd correspondant a dup et close dans la boucle redir
 
 des closes de fd a faire dans signal handler
 
 
 ------------------------------------------------------------------
 
 heredoc quand ctrl C ---> boucle plots et creer des heredocs vide 
 ----> regler avec pipe -->     << p | << r | ls   +   ctrl C
 
 verifier gestion erreur_cmd
 
 
 $o = 's -l'
 
 l$o -> 'ls -l' command not found a voir pour gerer ca apres le parsing var et avant remove quote

export a l air de se faire dans enfant des fois (apres un pwd)
