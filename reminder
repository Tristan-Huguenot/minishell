DONE 1 - gérer le nombre d'argument de ./minishell avec les erreurs -->  Tristan

DONE 1a- vérifier si les quotes sont toutes fermés !!!!!!!!!!!!!!!!!!!!!!!! faut renomer la func first_quote pour etre plus general d ailleurs on peut
surement utiliser ft_strchr a la place  ---- 

DONE 2 - séparer lorsqu'il y a un pipe == changer de structure
    si erreur de pipe c'est prio 0
    si non erreur 2a
DONE 2a -  création de structure

DONE 3 - interpréter les variables $ sauf si 'single quote'

DONE 3a - Recuperer in files et out files en laissant quote + remove des redir dans le cmd --> TRISTAN

PEUT ETRE Verifier variable dans les redirs

DONE 3b - separer args en laissant quotes  --> a voir

DONE 3 c -suprimer les quotes  --> NIL

IN progress  Ajouter interpretation $?  ->   penser à $12dsfsgd ça donne 2dsfsgd et 						rajouter les '_'  comme char valide.

			


creer une fonction qui verifie si Bulting sinon go execve 

4 - HEREDOC

5 - PIPEX

5 - REDIRECTION parsing à l'ouverture

6 - BUILTNGS

7 - gérer les signaux

DONE env ->
	precision, env n affiche pas les variable NULL c est a dire
	les variables definie comme ceci > "export VAR"
	contrairement a "export VAR=" qui n est pas NULL mais vide
	quand on appelle un exe on lui transmet les variables env mais pas
	les NULL du coup j ai modifier convert_env_strs pour ne transformer que
	les VAR non NULL le seul probleme c est que on peut allouer trop de
	memoire vu que ca se base sur envlink_size qui compte sans distinction
	des content NULL
	J ai verifier aussi d export une VAR NULL et ensuite de lancer un autre bash, 
	il ne recupere pas les variables NULL donc le convert_env_strs marchera niquel
	pour les execve en occultant les NULL

DONE echo NIL
cd 
pwd NIL getcwd, 
export TRISTAN 
	comme exit, si dans un pipe se fait dans un enfant et la variable
	export ou modifier ne l est que dans l enfant

	Les noms peuvent contenir chiffres (mais pas commencer par) et lettres et _ , d ailleurs il faudrat peut etre ajouter 
	des "|| char == '_'" dans les conditions de lecture du nom de variable
	pendant l interpretation

	si le nom est pas bon conduit a une erreur IDENTIFIER avec la chaine de char concerne
	Ca me fait me demander, on doit pas gerer les charactere speciaux 
	pour minishell, on devrait les chercher tous en faire un define 
	et si on tombe dessus dans l'input (sauf dans les quote et double)
	on fait un unexpected token,

	et pour finir comme dit plus haut "export VAR" la variable est nul
									  "export VAR=" variable vide

DONE unset TRISTAN

exit
	
	Plus d infor :	effectivement return le modulo 255 sur 8 bits donc
	long, et ensuite verifie si ce modulo est entre 0 - 127 et apres
	ce sont les signaux 128 + N (si en dehors range renvoir 0)
								ou N[0 - nombre de signaux gerer]. 

	Bash gere 7 signaux a partir de 0 donc 128 ... 134, je suppose que
	nous on devrait le mettre a 130, 
	pour l instant je vois que 3 signaux mais a voir.

	si l arg contient autre chose que 1 - ou + devant et des chiffres derriere
	-> exit avec code 2 et on ecrit erreur numeric argument required

	bizarement apres plein de test l argument est recuperer en tant que int normal puis cast en tant que unsigned int MAIS l'argument est accepte dans les limites d un long 

	Jpensais faire ca la mais tu verras l heure du message ahah, et y a plus de boulot que j avais prevu apres tous ces test jferais surement exit "demain"
